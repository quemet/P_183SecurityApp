# P_183SecurityApp

## Language de Programmation, Framework et Outils

![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white)
![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)

![NodeJS](https://img.shields.io/badge/node.js-6DA55F?style=for-the-badge&logo=node.js&logoColor=white)
![Nodemon](https://img.shields.io/badge/NODEMON-%23323330.svg?style=for-the-badge&logo=nodemon&logoColor=%BBDEAD)
![Express.js](https://img.shields.io/badge/express.js-%23404d59.svg?style=for-the-badge&logo=express&logoColor=%2361DAFB)
![JWT](https://img.shields.io/badge/JWT-black?style=for-the-badge&logo=JSON%20web%20tokens)

![Visual Studio Code](https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white)
![Git](https://img.shields.io/badge/git-%23F05033.svg?style=for-the-badge&logo=git&logoColor=white)
![GitHub](https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white)
![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)
![MySQL](https://img.shields.io/badge/mysql-4479A1.svg?style=for-the-badge&logo=mysql&logoColor=white)

## Sommaire

* [Route pour les utilisateurs](https://github.com/quemet/P_183SecurityApp/blob/main/project/app/routes/User.mjs)  
* [Fonction utilitaires](https://github.com/quemet/P_183SecurityApp/blob/main/project/app/routes/helper.mjs)  
* [Creation du token](https://github.com/quemet/P_183SecurityApp/blob/main/project/app/routes/Login.mjs)  
* [Traitement de la base de données](https://github.com/quemet/P_183SecurityApp/blob/main/project/app/db/database.mjs)  
* [Traitement de l'authentifcation](https://github.com/quemet/P_183SecurityApp/blob/main/project/app/auth/auth.mjs)  
* [Fichier du serveur](https://github.com/quemet/P_183SecurityApp/blob/main/project/app/server.mjs)
* [Cahier des charges](https://github.com/quemet/P_183SecurityApp/blob/main/Document/P_App-Webstore.pdf)
* [Rapport](https://github.com/quemet/P_183SecurityApp/blob/main/Document/Rapport-QuentinMétroz.docx)
* [Journal de travail](https://github.com/quemet/P_183SecurityApp/blob/main/Document/JNLTRAV-QuentinMétroz.xlsm)

## Configurer l'environment

### Installation de Docker

### Installation de Git

Rendez-vous ur l'url suivante : [Official Git WebSite](https://git-scm.com).

![Etape n°1](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_01.png)

Cliquer sur le bouton Download for windows en Bleu.

![Etape n°2](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_02.png)

Soit sur lien de 64 ou de 32 suivant votre machine.

![Etape n°3](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_03.png)

Quand l'installtion est fini, cliquer sur Ouvrir le fichier est cet fenêtre devrait apparaître.  
Cliquer sur Oui.

![Etape n°4](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_04.png)

Une Fenêtre s'ouvre puis cliqué sur continuer. 
Cette fenêtre parle des licences pour Git.

![Etape n°5](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_05.png)

Une nouvelle fenêtre apparaît. Celle ci nous demande ou mettre le dossier ou sera mis l'app.

![Etape n°6](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_06.png)

Cette fenêtre nous demande les composants à installer avec Git. 
Laisser ceux par défaut.

![Etape n°7](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_07.png)

Cette fenêtre demande pour faire un raccourci sur Git.

![Etape n°8](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_08.png)

Cette fenêtre demande l'éditeur de texte par défaut de Git.

![Etape n°9](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_09.png)

Cette fenêtre demande le nom de la branche initial quand un repo Git est crée.

![Etape n°10](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_10.png)

Cette fenêtre demande le chemin d'environment. Il ne faut pas toucher sur cette fenêtre.

![Etape n°11](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_11.png)

Cette fenêtre demande le protocole SSL. Ne touche pas non plus à cette fenêtre.

![Etape n°12](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_12.png)

Cette fenêtre demande pour le protocole HTTPS. Ne touche pas non plus à cette fenêtre.

![Etape n°13](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_13.png)

Cette fenêtre demande comment quitte est censé gérer les fin de fichiers.
Celon les OS cela peut changer. 
On laisse la valeur par défaut.

![Etape n°14](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_14.png)



![Etape n°15](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_15.png)
![Etape n°16](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_16.png)
![Etape n°17](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_17.png)
![Etape n°18](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_18.png)
![Etape n°19](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_19.png)
![Etape n°20](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_20.png)
![Etape n°21](https://github.com/quemet/P_183SecurityApp/blob/main/Image/Git/Screen_21.png)

### Installation de Visual Studio Code

### Installation des containeurs

Pour installer les containeurs.  
1. Cloner le répertoire actuelle avec la commande suivante :
   ```sh
   git clone https://github.com/quemet/P_183SecurityApp.git
   ```
2. Rendez vous dans le répertoire ou est mis le docker-compose :
   ```sh
   cd P_183SecurityApp/project
   ```
3. Executer la commande suivante pour créer les containeurs
   ```sh
   docker-compose up -d
   ```

### Installation de Node



### Installation de Nodemon

Mettez vous à la hauteur du package.json dans P_183SecurityApp/project/app.
Executer cette commande :

```sh
npm i nodemon --save-dev
```

### Installation de express

Mettez vous à la hauteur du package.json dans P_183SecurityApp/project/app.
Executer cette commande :

```sh
npm i express --save
```

### Installtion de JsonWebToken

Mettez vous à la hauteur du package.json dans P_183SecurityApp/project/app.
Executer cette commande :

```sh
npm i jsonwebtoken --save
```

### Installation de Crypto

Mettez vous à la hauteur du package.json dans P_183SecurityApp/project/app.
Executer cette commande :

```sh
npm i crypto --save
```

### Configuration de OpenSSL

Pour configurer OpenSSL nous avons utilisé la commande suivante :

```sh
openssl req -nodes -new -x509 -keyout server.key -out server.cert
```

OpenSSL nous pose les questions suivantes :

* Country Name (2 letter code) [AU]: CH
* State or Province Name (full name) [Some-State]:Vaud
* Locality Name (eg, city) []:Lausanne
* Organization Name (eg, company) [Internet Widgits Pty Ltd]:ETML
* Organizational Unit Name (eg, section) []:ETML
* Common Name (e.g. server FQDN or YOUR name) []:Quentin
* Email Address []:quentin.metroz@eduvaud.ch

J'ai récupéré les deux fichiers server.key et server.cert. 
J'ai créer un dossier qui s'appelle cert et j'ai mis les deux fichiers dedans.
Pour l'utilisation, aller voir [Utilisation des certif](./README.MD/'###Explication des routes')

## Explication du code

### Explication des routes

```JS
// impoter le module express
import express from "express"

// importer les fonction utilitaires
import { success, hashPassword } from "./helper.mjs"

// importer les fonctions en lien avec la base de données
import { getAllUser, getAllUserLike, getOneUser, createUser, updateUser, connection, deleteUser } from "../db/database.mjs";

// importer la fonction pour l'authentification
import { auth } from "../auth/auth.mjs";

// Instancier express
const userRouter = express();

// Première route asynchrone GET sur http://localhost:443/users avec authentification
userRouter.get('/', auth, async (req, res) => {
    // On check si l'utilisateur a passé un username dans l'url
    if (req.query.username) {
        // On limite la recherche pour éviter qu'elle soit trop gourmande en énergie
        if (req.query.name.length < 2) {
          const message = `Le terme de la recherche doit contenir au moins 2 caractères`;
          return res.status(400).json({ message });
        }

        // On mets une limite arbitraire à 3
        let limit = 3;

        // Si l'utilisateur donne une limite alors on réaffecte la variable
        if (req.query.limit) {
          limit = parseInt(req.query.limit, 10);
        }

        // Défini le message de réussite
        const message = "Voici la liste des utilisateurs récupéré";

        // Prend le user avec le username
        const results = await getAllUserLike(connection, req.query.username);

        // Envoie le message et les données sous format json
        res.json(success(message, results));
    }
    const message = "Voici la liste des utilisateurs récupéré";

    // On effectue une commande SQL si elle rate ou un problème durant la requête alors on affiche une erreur
    try {

        // On effectue une requête pour avoir tout les utilisateurs
        const results = await getAllUser(connection);

        // On l'envoie sous format json
        res.json(success(message, results));
    } catch (error) {

        // On défini un message d'erreur
        const message = "Erreur lors de la récupération des utilisateurs" + error;

        // On l'envoie sous format json
        res.status(500).json({ message });
    }
});

// Deuxième route asynchrone GET sur http://localhost:443/users/:id avec authentification
userRouter.get("/:id", auth, async (req, res) => {

    // On récupére l'id passé en paramètres
    const userId = req.params.id;

    // On effectue une commande SQL si elle rate ou un problème durant la requête alors on affiche une erreur
    try {

        // On effectue la requête pour avoir un seul utilisateur avec son username
        const user = await getOneUser(connection, userId);

        // Si la base de donnée nous renvoie un tableau vide alors on emmet une erreur 404
        if(user.length == 0) {

            // On défini le message d'erreur
            const message = `L'utilisateur dont l'id vaut ${userId} n'existe pas`;

            // on retourne un status 400 et le message sous format json
            return res.status(400).json({ message });
        }

        // Défini le message de réussite
        const message = `L'utilisateur dont l'id vaut ${userId} a bien été recupérée`;
        
        // On envoie le user et le message sous format json
        res.json(success(message, user));
    } catch(error) {

        // Défini le message d'erreur
        const message = `Erreur lors de la récupération de l'utilisateur dont l'id vaut ${userId}`;

        // Renvoie un status 500 et un message sous format json
        res.status(500).json({ message });
    } 
});

// Troisième route asynchrone POST sur http://localhost:443/users/ avec authentification
userRouter.post("/", auth, async (req, res) => {

    // Définir une variable josn avec les données envoyé par l'utilisateur
    let json = req.body;

    // Défin un objet JS vide
    let result = {};

    // On effectue une commande SQL si elle rate ou un problème durant la requête alors on affiche une erreur
    try {

        // On hash le mot de passe de l'utilisateur
        const password = hashPassword(json);

        // On change l'objet result pour contenir les données de l'utilisateur
        result = { username: json.username, password: password, isAdmin: json.isAdmin }

        // On crée l'utilisateur dans la base de données
        createUser(connection, result);

        // On défini le message pour la réussite
        const message = `Le user ${result.username} a bien été crée !`;

        // On envoie les donnée et message sous format json
        res.json(success(message, result));
    } catch(error) {

        // On défini le message pour l'échec
        const message = "Erreur lors de la création de l'utilisateur";

        // On evoie le staus 500 et sous format json le message et l'erreur
        res.status(500).json({ message, data: error });
    }
});

// Quatrième route asynchrone PUT sur http://localhost:443/users/:id avec authentification
userRouter.put("/:id", auth, async (req, res) => {

    // On défini une variable pour les données entré par l'utilisateur
    let json = req.body;

    // On défini une variable par l'id donné par l'utilisateur
    let userId = req.params.id;

    // On défini un objet JS vide
    let result = {};

    // On effectue une commande SQL si elle rate ou un problème durant la requête alors on affiche une erreur
    try {

        // On hash le password et met dans la variable password
        const password = hashPassword(json);

        // On implémete l'objet JS result avec les données de l'utilisateur
        result = { username: json.username, password: password, isAdmin: json.isAdmin }

        // On modifie l'utilisateur dans la base de données
        updateUser(connection, result, userId);

        // On défini le mesage pour la réussite
        const message = `Le user ${result.username} a bien été modifiée`;

        // On envoie le message et les données sous format JSON 
        res.json(success(message, result));
    } catch (error) {

        // On défini un messgae pour l'échec
        const message = "Erreur lors de la modification de l'utilisateur";

        // On evoie avec un statu 500 le message et l'erreur sous format json
        res.status(500).json({ message, data: error });
    }
});

// Cinquième route asynchrone DELETE sur http://localhost:443/users/:id avec authentification
userRouter.delete("/:id", auth, async (req, res) => {

    // On défini dans une variable l'id du user mis en paramètres
    const userId = req.params.id;

    // On défini une variable vide user
    let user;

    // On effectue une commande SQL si elle rate ou un problème durant la requête alors on affiche une erreur
    try {

        // Trouve le user avec son username
        user = await getOneUser(connection, userId);

        // Si la base de données nous renvoie un objet vide alors on emmet une erreur
        if(user.length == 0) {

            // On défini un messgae pour l'échec de la requête côté client
            const message = `L'utilisateur dont l'id vaut ${userId} n'existe pas`;

            // On renvoie un status 404 et le message sous format json
            return res.status(404).json({ message });
        }
    } catch(error) {

        // On défin un message pour l'échec du côte serveur
        const message = `Erreur lors de la récupération de l'utilisateur dont l'id vaut ${userId}`;

        // On renvoie un status 500 et le message sous format json
        return res.status(500).json({ message });
    }

    // On effectue une commande SQL si elle rate ou un problème durant la requête alors on affiche une erreur
    try {

        // On supprime l'utilisateur dans la base de données
        const result = await deleteUser(connection, userId).then((error) => error.message)

        // Si il n'y a pas d'erreur alors la db nous renvoie undefined sinon c'est qu'une erreur c'est produite
        if(result != undefined) {

            // On renvoie le statu 400 et le message de l'erruer sous format json
            res.status(400).json({ result })
        }

        // On défini un message pour la réussite de la requête
        const message = `L'utilisateur ${user.username} a bien été supprimée`;

        // On revoie le messaget et les données sous format JSON
        res.json(success(message, user));
    } catch(error) {

        // On défini un message pour l'échec de la requête
        const message = `Erreur lors de la suppression de l'utilisateur dont l'id vaut ${userId}`;

        // On renvoie le status 500 et le message sous fromat JSON
        res.status(500).json({ message });
    }
});

// On export le router
export { userRouter }
```

### Explication des fonction

```js

// import le module crypto
import crypto from "crypto";

// Cett fonction permet de transformer le message et les données en objet JS
const success = (message, data) => {
    // retourne un objet js avec le message et les données
    return {
        message: message,
        data: data
    }
}

// Cette fonction permet de haser les mot de passes
function hashPassword(json) {

    // Création d'un objet de hachage SHA-512
    const hash = crypto.createHash('sha512');

    // Mise à jour du hachage avec le mot de passe à hacher
    hash.update(json.password);

    // Finalisation du hachage et formatage en hexadécimal
    const password = hash.digest('hex');

    // Retourne le hachage du mot de passe
    return password;
}

// exporte les fonctions utilitaires à mon code
export { success, hashPassword }
```

### Explication de la création du token

```js

// importe le framework express
import express from "express";

// importe la librairie jsonwebtoken
import jwt from "jsonwebtoken";

// importe la fonction pour hasher
import { hashPassword } from "./helper.mjs"

// importe la connection et la fonction pour avoir un utilisateur par son username
import { connection, getOneUserWithName } from "../db/database.mjs";

// importe le clé privé
import { privateKey } from "../auth/private_key.mjs";

// création d'une instance d'express
const loginRouteur = express();

// Unique route du fichier asynchrone POST sur http://localhost:443/login sans authentification
loginRouteur.post("/", async (req, res) => {

    // Défini une variable du contenu des données entré par l'utilisateur
    let json = req.body;

    // Défini le mot de passe hasher
    let password = hashPassword(json);

    // On effectue une commande SQL si elle rate ou un problème durant la requête alors on affiche une erreur
    try {

        // On éxecute cette requête pour trouver l'utilisateur
        const user = await getOneUserWithName(connection, json.username);

        // Si la base de données nous renvoie un objet vide alors on emmet une erreur
        if(user.length == 0) {

            // On défini un message pour l'échec
            const message = `L'utilisateur demandé n'existe pas`;

            // On retourne un status 404 et une message sous format json
            return res.status(404).json({ message });
        }

        // Si les deux hash correspond alors on lui donne un token
        if(password == user[0].password) {

            // On crée le token avec un validation de 1an
            const token = jwt.sign({ userId: user[0].id, admin: user[0].isAdmin }, privateKey, {
                expiresIn: "1y",
            });

            // On défini le message pour la réussite de la connection
            const message = `L'utilisateur a été connecté avec succès`;

            // On renvoie sous format json le message, le user et le token
            return res.json({ message, data: user[0], token });
        // Cela signifie que c'est pas le bon mot de passe
        } else {

            // On défini un message pour l'échec
            const message = `Le mot de passe est incorrect`;

            // On renvoie un status 404 et un message sous fromat json
            return res.status(404).json({ message });
        }
    // On log l'erreur
    } catch(ex) {
        console.log(ex)
    }
});

// On export le router
export { loginRouteur };
```

### Explication du traitement de la base de données

```js

// On importe la librairie mysql2
import mysql from "mysql2/promise";

// On défini un variable vide
let connection;

// On essaie d'établir la connection avec la base de données
try {

    // Si vous êtes en local alors voici la bonne connection
    connection = await mysql.createConnection({
        host: "localhost",
        user: "root",
        password: "root",
        port: "3306",
        database: "db_securityapp" 
    });

    // Si vous êtes avec une application dockerisée alors voici la bonne connection
    /*connection = await mysql.createConnection({
        host: "172.24.0.3",
        user: "root",
        password: "root",
        port: "3306",
        database: "db_securityapp"
    });*/
} catch(ex) {
    console.log(ex)
    throw new Error("Cannot connect to the database. Please try again later")
}

// Cette fonction renvoie tout les utilisateurs de la base de données
const getAllUser = async (connection) => {

    // On essaie d'éxecuter la requête si celle ci échoue alors on emmet une erreue
    try {

        // Cette requête permet d'avoir tout les utilisateurs
        const [results] = await connection.query("SELECT * FROM users;");

        // On retourne le résultats
        return results;
    } catch (ex) {

        // On log l'erreur
        console.log(ex)

        // On emmet une erreur en fonction
        throw new Error("Cannot get all the users please try again later")
    }
}

// Cette fonction renvoie tout les utilisateurs avec le username
const getAllUserLike = async (connection, username) => {

    // On essaie d'éxecuter la requête si celle ci échoue alors on emmet une erreue
    try {

        // Cette requête permet d'obtenir tout les utilisateurs avec le username
        const [results] = await connection.query("SELECT * FROM users WHERE username LIKE ?;", [username]);

        // On retourne le résultat
        return results;
    } catch(ex) {

        // On log l'erreur
        console.log(ex)

        // On emmet une erreur
        throw new Error("Cannot get all the users with username " + username + ". Please try again later.")
    }
}

// Cett fonction renvoie l'utilisateur avec l'id 
const getOneUser = async (connection, userId) => {

    // On essaie d'éxecuter la requête si celle ci échoue alors on emmet une erreue
    try {

        // Cette requête permet d'obtenir l'utilisateur avec l'id
        const [results] = await connection.query(`SELECT * FROM users WHERE id=?;`, [userId]);
        
        // On retourne les resultats
        return results;
    } catch (ex) {

        // On log l'erruer
        console.log(ex)

        // On emmet une erreur
        throw new Error("Cannot get the user asked please try again later")
    }
}

// Cette fonction renvoie l'utilisateur avec son nom
const getOneUserWithName = async (connection, username) => {

    // On essaie d'éxecuter la requête si celle ci échoue alors on emmet une erreue
    try {

        // Cette requête permet d'obtenir le user avec le username
        const [results] = await connection.query(`SELECT * FROM users WHERE username=?`, [username]);
        
        // On retourne les resultats
        return results;
    } catch (ex) {

        // On log l'erreur
        console.log(ex)

        // On emmet une erreur
        throw new Error("Cannot find the user where the name is " + username + ". Please try again later")
    }
}

// Cette fonction crée l'utilisateur dans la base de données
const createUser = async (connection, data) => {

    // On essaie d'éxecuter la requête si celle ci échoue alors on emmet une erreue
    try {

        // Cette requête permet de créer l'utilisateur
        await connection.query(`INSERT INTO users(username, password, isAdmin) VALUES(?, ?, ?);`, [data.username, data.password, data.isAdmin]);
    } catch (ex) {

        // On log l'erreur
        console.log(ex);

        // On emmet une erreur
        throw new Error("Cannot create the user asked please try again later")
    }
}

// Cette fonction permet de mettre à jour l'utilisateur dans la base de données
const updateUser = async (connection, data, userId) => {

    // On essaie d'éxecuter la requête si celle ci échoue alors on emmet une erreue
    try {

        // Cett requête permet de mettre à jour
        await connection.query('UPDATE users SET username=?, password=?, isAdmin=? WHERE id=?', [data.username, data.password, data.isAdmin, userId]);
    } catch (ex) {

        // On log l'erreur
        console.log(ex)

        // On emmet une erreur
        throw new Error("Cannot update the user asked please try again later")
    }
};

// Cette fonction permet de supprimmer un utilisateur
const deleteUser = async (connection, userId) => {

    // On essaie d'éxecuter la requête si celle ci échoue alors on emmet une erreue
    try {

        // Cette requête permet de supprimmer
        return await connection.query(`DELETE FROM users WHERE id=?;`, [userId]);
    } catch (ex) {

        // On log l'erreur
        console.log(ex)

        // On emmet une erreur
        return new Error("Cannot delete the user asked please try again later")
    }
}

// export les fonction pour la base de données
export { getAllUser, getAllUserLike, getOneUser, getOneUserWithName, createUser, updateUser, deleteUser, connection }
```

### Explication du traitement de l' authentification

```js

// import de la librairie jsonwebtoken
import jwt from "jsonwebtoken";

// import de la clé privé
import { privateKey } from "./private_key.mjs";

// Cette fonction gére l'authentification pour une route
const auth = (req, res, next) => {

    // On récupére le jeton d'authentification avec le Bearer
    const authorizationHeader = req.headers.authorization;

    // On check si le jeton est vide
    if (!authorizationHeader) {

        // On défini un message d'erreur
        const message = `Vous n'avez pas fourni de jeton d'authentification. AJoutez-en dans l'en-tête de la requête.`;
        
        // On retourne un statu 401 et le message en format JSON
        return res.status(401).json({ message });
    } else {

        // On prend le token en enlevant le bearer au début
        const token = authorizationHeader.split(" ")[1];

        // On vérifie le token
        const decodedToken = jwt.verify(
            token,
            privateKey,
            (error, decodedToken) => {
                // Si il y a une erreur dans le décodage du token alors on donne une erreur
                if (error) {

                    // On défini un message d'erreur
                    const message = `L'utilisateur n'est pas autorisé à accéder à cette ressource.`;

                    // On retourne un statu 401 et le message, erreur en format json
                    return res.status(401).json({ message, data: error });
                }

                // On met l'id dans une variable
                const userId = decodedToken.userId;

                // On check si l'id donner dans le body n'est pas vide et si il correspond pas au celui du token
                if (req.body.userId && req.body.userId !== userId) {

                    // On défini un messgage d'erreur
                    const message = `L'identifiant de l'utilisateur est invalide`;

                    // On renvoie un statu 401 et le message sous format json
                    return res.status(401).json({ message });
                } else {

                    // On met le boolean de admin dans une variable
                    const isAdmin = decodedToken.admin

                    // Si il est pas admin alors on regarde la methode
                    if(!isAdmin) {

                        // C'est la méthode GET et qu'il a pasé un id pour autoriser unqieument que cett route à l'utilisateur 
                        if(req.method == "GET" && req.params.id) {

                            // On check si l'id de l'utilisateur est égal à l'id passé dans le body
                            if(req.params.id != userId) {

                                // On défini le message d'erreur
                                const message = `L'utilisateur n'est pas autorisé à accéder à cette ressource.`;

                                // On retourne le statu 401 et le message et l'erro sous format json
                                return res.status(401).json({ message, data: error });
                            }
                        } else {

                            // On déini le message d'erreur
                            const message = `L'utilisateur n'est pas autorisé à accéder à cette ressource.`;

                            // On retourne le statu 401 et le message et l'erro sous format json
                            return res.status(401).json({ message, data: error });
                        }
                    }

                    // Si tout se passe bien alors l' utilisateur est autorisé à éxécuter
                    next();
                }
            }
        );
    }
};

// exporte la fonction d'authentification
export { auth }
```

### Explication du fichier du serveur

```js

// import le framework express
import express from "express"

// import le router pour les users
import { userRouter } from "./routes/User.mjs";

// import le router pour le login
import { loginRouteur } from "./routes/Login.mjs";

// import la librairie fs pour lire des fichiers
import fs from "node:fs"

// import la librairie https pour monter le serveur
import https from "node:https"

// On fait une instanciation de express
const app = express();

// On défini les options pour monter notre serveur HTTPS
const options = { key: fs.readFileSync("cert/server.key"), cert: fs.readFileSync("cert/server.cert") };

// On crée le serveur https avec options, app et on le fait écouter le port 443
https.createServer(options, app).listen(443)

// On utilise express.json() pour transformer le json en objet JS
app.use(express.json());

// Pour les routes qui commence par https://localhost:443/users on appelle le router useRouter
app.use('/users', userRouter);

// Pour les routes qui commence par https://localhost:443/login on appelle le router loginRouter
app.use('/login', loginRouteur);
```

## Conclusion

J'ai trouvé ce projet intéressant car il m'apprit à passer de HTTP à HTTPS. 
Il y a aussi le fait de faire plus nous-même comme utiliser crypto plutôt bcrypt ou utiliser mysql2 plutôt que sequelize. 
Cela permet de coder une API REST sans trop de librairie et de faire la sécurité nous-même.
